#!/usr/bin/python
# Course export parsing script to create 'modulestore' file by scraping course export data 
# from edX; to be used to sync with Stanford's data scrubbing scripts if you don't want to
# spin up your own OpenEdX instance just to get modulestore information
#
# Developed in Python 2.7. Please report any bugs to the author.
# 
# Author: Kevin Kao
# Email: kkao@berkeley.edu
# Date: 4/26/14
# Version: 0.02a


import sys, os, glob, json
import xml.etree.ElementTree as ET
from xml.etree.ElementTree import tostring

# SETTINGS
PRETTIFY_JSON = False

# NOTES: ElementTree.parse only takes in a file path in the following form:
# 			folder/folder/file
# Do not place an additional "/" in front of the first folder (i.e. don't use buildPath)

# Helper function to build file paths
# baseFolder: the folder to start with
# folderHierarchy: the list of folders to traverse in order to build path
# 
# Outputted file path should be of the form: baseFolder/folder1/folder2/folder3/
def buildPath(baseFolder, folderHierarchy=[]):
	assert not baseFolder == None
	path = baseFolder

	for folder in folderHierarchy:
		if path[len(path)-1] == "/":
			path = path[0:len(path)-1]
		if not folder[0] == "/":
			folder = "/" + folder
		if folder[len(folder)-1] == "/":
			folder = folder[0:len(folder)-1]
		path = path + folder + "/"

	if path[0] == "/":
		path = path[1:len(path)]
	if not path[len(path)-1] == "/":
		path = path + "/"
	return path

# Outputted file path should be of the form baseFolder/folder1/folder2/finalFile
def buildPathWithFile(baseFolder, folderHierarchy, finalFile):
	assert not finalFile == None
	if finalFile[0] == "/":
		finalFile = finalFile[1:len(finalFile)]
	return buildPath(baseFolder, folderHierarchy) + finalFile

# Removes all slashes from file path
def clean(word):
	if word[0] == "/":
		word = word[1:len(word)]
	if word[len(word)-1] == "/":
		word = word[0:len(word)-1]
	return word

# Abstraction purposes to output "prettified" JSON form of modulestore
def toJSON(entry_dict):
	if PRETTIFY_JSON:
		return json.dumps(entry_dict, sort_keys=True, indent=4, separators=(',', ': '))
	else:
		return json.dumps(entry_dict, sort_keys=True)

# Writes the entry as JSON to the output file on disk
def write(output_file, entry):
	output_file.write(toJSON(entry) + "\n")

#############################################################################
# To better understand parser:
#	- a COURSE has a list of CHAPTERS --> ('course' folder)
#	- each CHAPTER has a list of SEQUENTIALS --> ('chapter' folder)
#	- each SEQUENTIAL has a list of verticals --> ('sequential' folder)
#############################################################################

###### MAIN METHOD #####
def main():
	print "Starting modulestore generator..."

	arglen = len(sys.argv)
	arglist = sys.argv[1:]
	modulestore = file("test_modulestore.json", "w")

	#########################################################################################
	## This dictionary is used for linking purposes
	## INFORMATION:
	## 	"chapters" stores a dictionary in this format:
	##		{ chapterHash : [chapterDisplayName, [list of sequentials]] }
	## 	"sequentials" stores a dictionary in this format:
	##		{ sequentialHash : [seqDisplayName, [list of verticals], chapterHash] }
	## 	"verticals" stores a dictionary in this format:
	##		{ verticalHash : [verDisplayName, [list of html/prob], seqHash] }
	##	
	## For modules, there are several kinds, including problems, videos, html, etc...
	## To generalize for the future, these are not explicitly added into the dictionary.
	## They will be added dynamically as the parser discovers new module types in the export.
	##	"module_type" stores a dictionary in this format:
	##		{ moduleHash : [moduleDisplayName, verticalHash] }
	##
	## Module types will be kept track of in a list to dynamically find folders in exports
	#########################################################################################
	content_linker = { "chapters" : {},	"sequentials" : {},	"verticals" : {} }
	module_list = []

	# first argument should be path to root folder
	if arglen == 1:
		print "Invalid arguments. " \
			"Usage: ./parse root_folder_of_course_export"
		exit(1)

	# grab root folder of course export
	course_export = buildPath(arglist[0])
	root_folder = os.path.dirname( os.getcwd() + "/" + course_export )
	if not os.path.exists(root_folder):
		print "Invalid file path: " + root_folder	
		exit(1)

	# parse for course information first
	sys.stdout.write("Parsing course information for ")
	tree = ET.parse(course_export + "course.xml")
	root = tree.getroot()
	course = root.attrib["course"]
	org = root.attrib["org"]
	tag = "i4x"
	sys.stdout.write(str(course) + "...\n")

	# parse 'about' folder of course export
	sys.stdout.write("Parsing 'about' folder...\t")
	f = open(buildPath(course_export, ["about"]) + "overview.html", "r")
	entry_dict = { "_id" : {"tag" : tag, "org" : org, "course" : course, "category" : "about", \
				"name" : "overview", "revision" : None }, "definition" : { "children" : [], \
				"data": f.read() }, "metadata" : {} }
	write(modulestore, entry_dict)
	sys.stdout.write("success!\n")

	# parse 'chapter' folder of course export
	sys.stdout.write("Parsing 'chapter' folder...\t")
	files = os.listdir(buildPath(course_export, ["chapter"]))
	for chapter_file in files:
		tree = ET.parse(buildPath(course_export, ["chapter"]) + chapter_file)
		root = tree.getroot()

		chapter = chapter_file.replace(".xml", "")
		display_name = root.attrib["display_name"]

		entry_dict = { "_id" : { "tag" : tag, "org" : org, "course" : course, "category" : "chapter", \
					"name" : chapter, "revision" : None }, "definition" : { \
					"children" : [], "data": {} }, "metadata" : { "start" : "", "xml_attributes" : \
					{ "filename" : [] }, "display_name" : display_name } }
		if "start" in root.attrib:
			entry_dict["metadata"]["start"] = root.attrib["start"]
		entry_dict["metadata"]["xml_attributes"]["filename"].append("chapter/" + chapter_file)
		
		# update content_linker
		content_linker["chapters"][chapter] = [ root.attrib["display_name"], []]

		for sequential in root:
			# update content_linker
			content_linker["chapters"][chapter][1].append(sequential.attrib["url_name"])
			content_linker["sequentials"][sequential.attrib["url_name"]] = [ None, [], chapter]

			child = tag + "://" + org + "/" + course + "/sequential/" + sequential.attrib["url_name"]
			entry_dict["definition"]["children"].append(child)
		write(modulestore, entry_dict)
	sys.stdout.write("success!\n")

	# parse 'course' folder of course export
	# also involves 'policies' folder
	# incomplete metadata and definition
	sys.stdout.write("Parsing 'course' folder...\t")
	files = os.listdir(buildPath(course_export, ["course"]))

	if len(files) != 1:
		print "Strange error with multiple files in course folder. Please contact author of script."
		print "Include the list of files with your email: "
		print files
		exit(1)

	alt_course_name = files[0].replace(".xml", "")

	tree = ET.parse(buildPathWithFile(course_export, ["course"], files[0]))
	root = tree.getroot()
	data_dict = { "textbooks" : [], "grading_policy" : {}, "wiki_slug" : "" }
	entry_dict = { "_id" : { "tag" : tag, "org" : org, "course" : course, "category" : "course", \
				"name" : files[0].replace(".xml", ""), "revision" : None }, "definition" : { \
				"children" : [], "data": data_dict }, "metadata" : { "start" : "", "xml_attributes" : \
				{ "filename" : [] }, "display_name" : "", "advanced_modules" : [], "tabs" : []} } 
	if "start" in root.attrib:
		entry_dict["metadata"]["start"] = root.attrib["start"]
	entry_dict["metadata"]["xml_attributes"]["filename"].append("course/" + files[0])
	entry_dict["metadata"]["xml_attributes"]["display_name"] =  root.attrib["display_name"]
	
	# store chapters and wiki slug into entry
	for chapter in root:
		if chapter.tag == "chapter":
			child = tag + "://" + org + "/" + course + "/chapter/" + chapter.attrib["url_name"]
			entry_dict["definition"]["children"].append(child)
		if chapter.tag == "wiki" and "slug" in chapter.attrib:
			entry_dict["definition"]["data"]["wiki_slug"] = chapter.attrib["slug"]
	sys.stdout.write("success!\n")

	# let's take care of the policy.json in policies folder first
	sys.stdout.write("Parsing 'policies' folder...\t")
	try:
		files = os.listdir(buildPath(course_export, ["policies", alt_course_name]))
	except:
		print "Something went wrong with the parsing of 'policy' folder. Please contact author."
		exit(1)

	for json_file in files:
		# policy.json stores information about tabs/metadata
		json_data = open(buildPathWithFile(course_export, ["policies", alt_course_name], json_file), 'r')
		if json_file == "policy.json":
			COURSE_INFO = json.load(json_data)
			key = "course" + "/" + clean(alt_course_name)
			entry_dict["metadata"]["tabs"] = COURSE_INFO[key]["tabs"]
			entry_dict["metadata"]["discussion_topics"] = COURSE_INFO[key]["discussion_topics"]
		# grading_policy stores information
		elif json_file == "grading_policy.json":
			GRADER_CONTENTS = json.load(json_data)
			entry_dict["definition"]["data"]["grading_policy"]["GRADE_CUTOFFS"] \
				= GRADER_CONTENTS["GRADE_CUTOFFS"]
			entry_dict["definition"]["data"]["grading_policy"]["GRADER"] \
                = GRADER_CONTENTS["GRADER"]
		else:
			print "Unexpected file: " + str(json_file)
			print "Please contact author of script and include name of the file."
			exit(1)
		json_data.close()
	write(modulestore, entry_dict)
	sys.stdout.write("success!\n")

	# parse 'sequential' folder of course export
	sys.stdout.write("Parsing 'sequential' folder...\t")
	files = os.listdir(buildPath(course_export, ["sequential"]))
	for sequential_file in files:
		tree = ET.parse(buildPathWithFile(course_export, ["sequential"], sequential_file))
		root = tree.getroot()

		sequential = sequential_file.replace(".xml", "")
		display_name = root.attrib["display_name"]

		entry_dict = { "_id" : { "tag" : tag, "org" : org, "course" : course, "category" : "sequential", \
				"name" : sequential, "revision" : None }, "definition" : { \
				"children" : [], "data": {} }, "metadata" : { "start" : "", "xml_attributes" : \
				{ "filename" : ["sequential/" + sequential_file] }, "display_name" : display_name } }

		# update content_linker
		content_linker["sequentials"][sequential][0] = display_name

		# store verticals into children of entry
		for vertical in root:
			child = tag + "://" + org + "/" + course + "/vertical/" + vertical.attrib["url_name"]
			entry_dict["definition"]["children"].append(child)
			
			# update content_linker
			content_linker["sequentials"][sequential][1].append(vertical.attrib["url_name"])
			content_linker["verticals"][vertical.attrib["url_name"]] = [ None, [], sequential]
		write(modulestore, entry_dict)
	sys.stdout.write("success!\n")

	
	# parse 'vertical' folder of course export
	# verticals have no file name (???)
	sys.stdout.write("Parsing 'vertical' folder...\t")
	files = os.listdir(buildPath(course_export, ["vertical"]))
	for vertical_file in files:
		tree = ET.parse(buildPathWithFile(course_export, ["vertical"], vertical_file))
		root = tree.getroot()

		vertical = vertical_file.replace(".xml", "")
		display_name = root.attrib["display_name"]

		entry_dict = { "_id" : { "tag" : tag, "org" : org, "course" : course, "category" : "vertical", \
				"name" : vertical, "revision" : None }, "definition" : { \
				"children" : [], "data": {} }, "metadata" : { "start" : "", "xml_attributes" : \
				{ "filename" : ["vertical/" + vertical_file] }, "display_name" : display_name } }

		# update content_linker
		content_linker["verticals"][vertical][0] = display_name

		# store modules into children of entry
		for module in root:
			module_type = module.tag
			module_name = module.attrib["url_name"]

			child = tag + "://" + org + "/" + course + "/" + module_type + "/" + module_name
			entry_dict["definition"]["children"].append(child)
			
			# update content_linker
			content_linker["verticals"][vertical][0] = display_name
			content_linker["verticals"][vertical][1].append(module_name)
			if not module_type in content_linker:
				content_linker[module_type] = {}
			content_linker[module_type][module_name] = [ None, vertical] 

			# add to list of module_types if not there
			if not module_type in module_list: 
				module_list.append(module_type)
		write(modulestore, entry_dict)
	sys.stdout.write("success!\n")

	# parse each module type's folder of course export
	# have to determine how to read "data" in for diff. module types
	for module in module_list:
		sys.stdout.write("Parsing module '" + str(module) + "'...\t")
		try:
			module_type = str(module)
			files = os.listdir(buildPath(course_export, [module_type]))
			
			for module_file in files:
				if module_file.endswith('.xml'):
					name = module_file.replace(".xml", "")
					
					data = ""
					tree = ET.parse(buildPathWithFile(course_export, [module_type], module_file))
					root = tree.getroot()

					if module_type == "problem":
						data = ET.tostring(root)
					elif module_type == "video":
						# xml attributes will be parsed below
						pass
					elif module_type == "html":
						# add html contents to data
						filePath = buildPathWithFile(course_export, [module_type], name + ".html")
						if os.path.isfile(filePath):
							html_data = open(filePath)
							data = html_data.read()
					else:
						pass

					# display_name of a module is the display_name of its vertical
					vertical = content_linker[module_type][name][1]
					display_name = content_linker["verticals"][vertical][0]

					f = open(buildPathWithFile(course_export, [module_type], module_file), "r")
					entry_dict = { "_id" : { "tag" : tag, "org" : org, "course" : course, "category" : module_type, \
		                    "name" : name, "revision" : None }, "definition" : { \
		                    "data": data }, "metadata" : { "xml_attributes" : \
		                    { "filename" : [ module_type + "/" + module_file ] }, "display_name" : display_name } }
		            
					for attribute in root.attrib:
						entry_dict["metadata"]["xml_attributes"][attribute] = root.attrib[attribute]
					
					write(modulestore, entry_dict)
			sys.stdout.write("success!\n")					
		except OSError:
			print "No '" + module_type + "' folder in this course..."
			pass

if __name__ == '__main__': main()
